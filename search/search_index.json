{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the tutorial: mapping burned area with Deep Learning","text":""},{"location":"#about-the-tutorial","title":"About the tutorial","text":"<p>This tutorial is an effort to provide processing code strings for the purpose of using Deep Learning architectures for land cover disturbance mapping, combining Google Earth Engine and Google Colab. This material essentially focuses on mapping burned areas at a regional scale, so that it can be replicated for local or larger scale work.</p>"},{"location":"#wildfire","title":"Wildfire","text":"<p>Human actions are driving significant changes in land cover, intensifying climate change challenges and posing critical threats to communities and ecosystems. These changes arise from various processes and drivers, operating at different scales. It is crucial to capture these diverse processes explicitly in space and time to support scientific and societal applications that go beyond mere geographic representation of disturbances. Wildland fires offer a unique chance to study the role of abrupt land cover change, gradual recovery, and the establishment of new equilibria. Satellite remote sensing provides valuable data on fire location, magnitude, and recovery.</p> <p>For future citations of this work, please use:</p>"},{"location":"#some-sentinel-2-burned-areas-patches","title":"Some Sentinel-2 burned areas patches","text":""},{"location":"Downloading%20patches/","title":"Downloading patches from Google Earth Engine","text":"<p>Google Earth Engine (GEE) is a geospatial processing service. GEE allows users to run algorithms on georeferenced imagery and vectors stored on Google's infrastructure. The GEE API provides a library of functions which may be applied to data for display and analysis.With Earth Engine, you can perform geospatial processing at scale, powered by Google Cloud Platform. The purpose of Earth Engine is to:</p> <ol> <li>Provide an interactive platform for geospatial algorithm development at scale</li> <li>Enable high-impact, data-driven science</li> <li>Make substantive progress on global challenges that involve large geospatial datasets</li> </ol>"},{"location":"Downloading%20patches/#01-libraries-to-be-used","title":"01. Libraries to be used:","text":"<pre><code>import ee\nimport geemap as emap\n</code></pre> <p>Selecting a specific basemap as follow:</p> <pre><code>Map = emap.Map()\nMap.add_basemap(\"SATELLITE\")\n</code></pre>"},{"location":"Downloading%20patches/#02-authentication-and-initialization","title":"02. Authentication and Initialization","text":"<p>Prior to using the Earth Engine Python client library, you need to authenticate and use the resultant credentials to initialize the Python client. To initialize, you will need to provide a project that you own, or have permissions to use. This project will be used for running all Earth Engine operations:</p> <pre><code>ee.Authenticate()\nee.Initialize(project='ee-geoyons')\n</code></pre> <p>See the authentication guide for troubleshooting and to learn more about authentication modes and Cloud projects.</p>"},{"location":"Downloading%20patches/#03-connecting-to-gee","title":"03. Connecting to GEE","text":"<pre><code>tile = ee.List([30])\n\nport_tiles = ee.FeatureCollection(\"projects/ee-geoyons/assets/tiles_portugal_50km\")\nlabel = ee.Image(\"projects/ee-geoyons/assets/raster_ardida_2017\")\nfeatures = port_tiles.filter(ee.Filter.inList('id', tile));\n\n# Define a collection\ncolS2 = 'COPERNICUS/S2_SR_HARMONIZED'\n\n# NBR function\ndef addNBR (image):\n  nbr = image.normalizedDifference(['B8', 'B12']).rename(\"NBR\");\n  return image.addBands(nbr);\n\n# masking clouds\ndef maskSQA(image):\n  qa = image.select('QA60')\n  opaque_cloud = (1 &lt;&lt; 10);\n  cirrus_cloud = (1 &lt;&lt; 11);\n  mask = qa.bitwiseAnd(opaque_cloud).eq(0).And(qa.bitwiseAnd(cirrus_cloud).eq(0));\n  return image.updateMask(mask);\n\ncloud_cover = 10;\n\nbnames = ['B2', 'B3', 'B4', 'B5','B6','B7','B8','B8A','B11','B12']\n\n# Dates AFTER the fire event\nstart_date_after = '2017-09-30';\nend_date_after = '2017-12-30';\n\nimg2017 = ee.ImageCollection(colS2)\\\n                .filterBounds(features)\\\n                .filterDate(start_date_after, end_date_after)\\\n                .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', cloud_cover))\\\n                .map(maskSQA)\\\n                .select(bnames)\\\n                .reduce(ee.Reducer.median())\n\nnbrColl = ee.ImageCollection(colS2)\\\n                .filterBounds(features)\\\n                .filterDate(start_date_after, end_date_after)\\\n                .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', cloud_cover))\\\n                .map(maskSQA)\\\n                .select(bnames)\\\n                .map(addNBR)\\\n                .reduce(ee.Reducer.min());\n\nnbr = nbrColl.select('NBR_min');\n\n# Dates BEFORE the fire event\nstart_date_before = '2020-09-30'; # '2017-04-01';\nend_date_before = '2020-12-30'; # '2017-06-15'\n\nnbrColl2 = ee.ImageCollection(colS2)\\\n                .filterBounds(features)\\\n                .filterDate(start_date_before, end_date_before)\\\n                .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 90))\\\n                .map(maskSQA)\\\n                .select(bnames)\\\n                .map(addNBR)\\\n                .reduce(ee.Reducer.mean());\n\nnbr_before = nbrColl2.select('NBR_mean');\n\nnbr_diff = nbr.subtract(nbr_before);\n</code></pre> <pre><code>vizParams = {\n  \"bands\": ['B12_median', 'B8_median', 'B4_median'],\n  \"min\": 0,\n  \"max\": 3500,\n  \"gamma\": [0.95, 1.1, 1]\n  };\n\n# Definimos los parametros de visualizacion\nparams_nbr = {\n  \"bands\": ['NBR_min'],\n  \"min\": -0.5,\n  \"max\": 0.6,\n  \"palette\": ['FFFFFF','CC9966','CC9900','996600', '33CC00', '009900','006600']};\n\n# Definimos los parametros de visualizacion\nparams_nbr_before = {\n  \"bands\": ['NBR_mean'],\n  \"min\": -0.5,\n  \"max\": 0.6,\n  \"palette\": ['FFFFFF','CC9966','CC9900','996600', '33CC00', '009900','006600']};\n\nMap.centerObject(features, 9)\nMap.addLayer(features, {},'Portugal tile', True);\nMap.addLayer(img2017.clip(features), vizParams, 'S2 - post-fire event 2017');\nMap.addLayer(nbr_before.clip(features), params_nbr_before, 'NBR before', True);\nMap.addLayer(nbr.clip(features), params_nbr, 'NBR after', True);\nMap.addLayer(nbr_diff.clip(features), {min: -0.8, max: 0.2}, 'NBR Difference', True);\nMap\n</code></pre> <pre><code>export_options = {\n  'patchDimensions': [512, 512], #512*512\n  'maxFileSize': 104857600,\n  'compressed': True\n}\n\nee.batch.Export.image({\n  \"image\": d3.clip(features).double(),\n  \"description\": 'PatchesExport',\n  \"fileNamePrefix\": 'Port_tile30',\n  \"scale\": 10, # resolution\n  \"folder\": 'California_patches_512-512_radar',\n  \"fileFormat\": 'TFRecord',\n  \"region\": features,\n  \"formatOptions\": export_options,\n  \"maxPixels\": 1e+13,\n})\n</code></pre>"}]}